## 事务的隔离级别有哪些？怎么实现？

* 读未提交，指一个事务还没提交时，它做的变更就能被其他事务看到
* 读已提交，指一个事务提交之后，它做的变更才能被其他事务看到
* 可重复读，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据时一致的，**MySQL InnoDB 引擎的默认隔离级别**
* 串行化，会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突，后访问的事务必须等前一个事务执行完成，才能继续执行

![image-20241105011346256](C:\Users\Napoleon\Desktop\学习记录\photo\image-20241105011346256.png)

---

MySQL InnoDB 引擎的默认隔离级别虽然是 *可重复读*  ，可以很大程度上避免幻读现象，但是不是完全解决了。

**解决的方案有两种：**

* 针对**快照读**（普通 select 语句），是通过MVCC方式解决了幻读，因为在可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的。
* 针对**当前读**（select ... for update 等语句），是通过 next-key lock （记录锁 + 间隙锁） 方式解决了幻读，因为在执行 select ... for update 语句的时候，会加上 next-key lock,如果有其他事务在 next-key lock 锁范围内插入一条记录，会被阻塞，无法成功插入。

---

四种隔离级别具体如何实现？

* 对于**读未提交** 隔离级别来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了
* 对于 **串行化** 隔离级别来说，通过加读写锁的方式来避免并行访问
* 对于 **读已提交** 和 **可重复读** 隔离级别的事务来说，他们都是通过 **Read View 来实现的，他们的区别在于创建 Read View 的时机不同，【读已提交】隔离级别是在 【每个语句执行前】都会生成一个 Read View ，而【可重复读】隔离级别是【启动事务时】生成一个 Read View ，然后整个事务期间都在用这个 Read View**

---

MVCC是什么？解决了什么问题？实现原理？

通过事务的 **Read View** 里的字段 和 **记录中的两个隐藏列**  的对比，来控制并发事务访问同一个记录时的行为，叫MVCC(多版本并发控制)

解决了 **读已提交** 和 **可重复读** 的隔离级别

实现原理是，通过比较事务的 **trx_id** 值，如果这个值小于 Read View 中最小的值，说明该版本的记录对当前事务可见。

如果大于等于 Read View 中最大的值 ，说明该版本的记录对当前事务不可见。

还有一种是在 Read View 的最小、最大值之间的，需要判断 trx_id 的值是否在 m_ids 列表中，如果在，表示生成该版本记录的活跃事务依然活跃着，所以该版本的记录对当前事务不可见。如果不在，可见。

---



![image-20241105020112343](C:\Users\Napoleon\Desktop\学习记录\photo\image-20241105020112343.png)

![image-20241105020058744](C:\Users\Napoleon\Desktop\学习记录\photo\image-20241105020058744.png)