## 索引失效

- 当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效;
- 当我们在查询条件中对索引列使用函数，就会导致索引失效。
- 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。
- MySQL在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR后的条件列不是索引列，那么索引会失效。or 条件两边都有索引，才能使索引生效



- 对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。
- 那么多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引。
- 创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引(a,b, c)和(c,b, a)在使用的时候会存在差别。
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。

比如，如果创建了一个(a，b，c)联合索引，如果查询条件是以下这几种，就可以匹配上联合索引:
where a=1;
where a=1 and b=2 and c=3;
where a=1 and b=2.
需要注意的是，因为有查询优化器，所以a字段在 where 子句的顺序并不重要
但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就
会失效:
where b=2;
where c=3;
where b=2 and c=3;
有一个比较特殊的查询条件:where a=1and c=3，符合最左匹配吗?
这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。
MySQL 5.5 的话，前面a会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对c字段的值。

从 MySQL 5.6 之后，有一个索引下推功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。

索引下推的大概原理是:截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断(因为c字段的值是在(a，b,c)联合索引里的)，然后过滤出符合条件的数据后再返回给Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。

